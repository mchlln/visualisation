[{"name":"app.R","content":"# install.packages(\"shiny\", repos = \"http://cran.us.r-project.org\", dependencies = TRUE)\nlibrary(shiny)\nlibrary(leaflet)\nlibrary(bslib)\nlibrary(arrow)\nlibrary(geosphere)\nlibrary(sf)\nlibrary(dplyr)\n\nsource(\"global.R\")\n\nsource(\"./src/ui.R\")\nsource(\"./src/server.R\")\nshinyApp(ui, server)\n","type":"text"},{"name":"README.md","content":"# Fouille Extraction Visualisation\n\n## Ressources\n\n- [Jeu de donnée: data.gouv](https://www.data.gouv.fr/datasets/donnees-sur-la-localisation-et-lacces-de-la-population-aux-equipements/)\n- [Légende des équipements utilisés](https://www.insee.fr/fr/metadonnees/source/operation/s2216/presentation)\n- [Légende des équipements utilisés (CSV)](https://www.insee.fr/fr/metadonnees/source/fichier/BPE24_table_passage.csv)\n- [Données sur les dépenses culturelles](https://www.data.gouv.fr/datasets/depenses-culturelles-des-communes/)\n- [Données sur les dépenses en santé](https://www.data.gouv.fr/datasets/open-damir-base-complete-sur-les-depenses-dassurance-maladie-interregimes)\n- [Données sur les communes](https://www.data.gouv.fr/datasets/data-insee-sur-les-communes)\n\n## Idées:\n\n- Identifier les zones les plus isolées, les plus denses en équipement\n- Voir s'il y a une corrélation entre l'éloignement à des services de santé et les dépenses en santé des habitants.\n- Distance avec les équipements et rapport avec le salaire moyen des habitants\n- Voir s'il y a une liaison entre la présence d'établissements d'éduction supérieure et de certains types d'équipements\n- Est-ce que les communes qui ont peu d'établissements culturels dépensent moins en budget culturel par habitant que celles avec beaucoup d'établissments culturels\n- Est-ce que les dépenses en culture augmentent plus on se trouve proche d'un équipement culturel\n- Quel équipement fait le plus grimper le prix de l'immobilier\n- Types d'équipement en fonction de la densité : est-ce qu'à partir d'une certaine densité, on retrouve certains équipements plus proches\n- Quel est le sport le plus accessible selon l'endroit de vie (terrains de foot + présents à la campagne/périphérie, salle de sport en centre ville)\n- Une ville qui dépense plus a des haibtants plus proches de lieux pour la culture ?\n\n## Technique\n\n- R\n- PostGreSQL pour nos données : peut être distant, possibilité de faire des opérations SQL\n- package arrow pour gérer les .parquet\n- dplyr pour faire un workflow lazy (execution seulement quand on le demande et directement sur disque)\n- Shiny pour faire de l'interractif\n\n## Project Set-up\n\n### Linux\n\n#### Conda + Shiny App\n- Run `wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh` to download MiniConda installer\n- Run `bash Miniconda3-latest-Linux-x86_64.sh`\n- Follow installer instructions\n- Create environment:\n  - For runtime: `conda env create -f environment.yml`\n  - For development: `conda env create -f environment-dev.yml` (r-studio-desktop included)\n- run `conda activate shiny-visualisation` to load the environment\n- run `R -e \"shiny::runApp('./')\"` to run the App\n\n#### Database (docker)\n- run `docker compose up -d` to start the container\n- run `docker compose down -v` to stop and clean container\n\n#### Test remote\n- ssh `ssh -L 8080:localhost:8080 formation`","type":"text"},{"name":"docker-compose.yml","content":"version: '3.8'\n\nservices:\n  db:\n    image: postgres:16-alpine\n    container_name: postgres_db\n    restart: always\n    \n    environment:\n      POSTGRES_USER: visualisation\n      POSTGRES_PASSWORD: visualisation\n      POSTGRES_DB: shiny_db\n      \n    ports:\n      - \"5432:5432\"\n      \n    volumes:\n      - pg_data:/var/lib/postgresql/data \n\nvolumes:\n  pg_data:","type":"text"},{"name":"environment-dev.yml","content":"name: shiny-visualisation\nchannels:\n  - conda-forge\ndependencies:\n  - r-base\n  - r-shiny\n  - r-dplyr\n  - r-dbplyr\n  - r-dbi\n  - r-rpostgres\n  - r-leaflet\n  - r-bslib\n  - r-arrow\n  - r-geosphere\n  - r-sf\n  - rstudio-desktop\n  - r-shinyWidgets","type":"text"},{"name":"environment.yml","content":"name: shiny-visualisation\nchannels:\n  - conda-forge\ndependencies:\n  - r-base\n  - r-shiny\n  - r-dplyr\n  - r-dbplyr\n  - r-dbi\n  - r-rpostgres\n  - r-leaflet\n  - r-bslib\n  - r-arrow\n  - r-geosphere\n  - r-sf\n  - r-shinyWidgets","type":"text"},{"name":"global.R","content":"library(DBI)\nlibrary(RPostgres)\n\ndb_host <- Sys.getenv(\"DB_HOST\")\ndb_port <- Sys.getenv(\"DB_PORT\")\ndb_name <- Sys.getenv(\"DB_NAME\")\ndb_user <- Sys.getenv(\"DB_USER\")\ndb_password <- Sys.getenv(\"DB_PASSWORD\")\n\n\ntryCatch(\n    {\n        conn <- dbConnect(\n            RPostgres::Postgres(),\n            dbname = Sys.getenv(\"DB_NAME\", \"shiny_db\"),\n            host = Sys.getenv(\"DB_HOST\", \"127.0.0.1\"),\n            port = Sys.getenv(\"DB_PORT\", 5432),\n            user = Sys.getenv(\"DB_USER\", \"visualisation\"),\n            password = Sys.getenv(\"DB_PASSWORD\", \"visualisation\")\n        )\n        message(\"Connected successfully\")\n\n\n        is_empty <- function(con, table) {\n            tryCatch(\n                {\n                    query <- sprintf(\"SELECT COUNT(*) AS n FROM %s;\", table)\n                    n <- dbGetQuery(con, query)$n\n                    return(n == 0)\n                },\n                error = function(e) {\n                    return(TRUE)\n                }\n            )\n        }\n\n        if (is_empty(conn, \"equipment_access\")) {\n            message(\"Reading Parquet file...\")\n            df <- read_parquet(\"data/donnees-2024-reg94.parquet\")\n            df_data_frame <- as.data.frame(df)\n            message(\"Writing to Database...\")\n            dbWriteTable(conn, \"equipment_access\", df_data_frame, overwrite = TRUE, row.names = FALSE)\n            message(\"Success! Data loaded.\")\n        } else {\n            message(\"Database already loaded, skipping data load\")\n        }\n\n        legend <- read.csv(file = \"data/BPE24_table_passage.csv\", sep = \";\", header = T)\n\n        culture <- read.csv(file = \"data/depenses-culturelles-des-communes-total-2023-2023.csv\", sep = \",\", header = T)\n        # print(culture)\n        # print(legend)\n\n        # dbDisconnect(conn)\n    },\n    error = function(e) {\n        message(\"DB ERROR: \", e$message)\n    }\n)\n","type":"text"},{"name":"src/server.R","content":"library(shiny)\n\nfetchDB <- function(input) {\n  north_lat <- input$map_background$north\n  south_lat <- input$map_background$south\n  leafletProxy(\"map_background\") %>%\n    clearMarkers() %>%\n    clearShapes()\n\n  df <- data.frame(c(input$map_background_bounds$west, input$map_background_bounds$east), c(input$map_background_bounds$north, input$map_background_bounds$south))\n  colnames(df) <- c(\"X\", \"Y\")\n\n  data_sf_orig <- st_as_sf(\n    df,\n    coords = c(\"X\", \"Y\"),\n    crs = 4326\n  )\n\n  data_sf_3035 <- st_transform(data_sf_orig, 3035)\n\n  coords_3035 <- st_coordinates(data_sf_3035)\n  x_min <- min(coords_3035[, 1])\n  x_max <- max(coords_3035[, 1])\n  y_min <- min(coords_3035[, 2])\n  y_max <- max(coords_3035[, 2])\n\n  max_fetch <- input$slider\n\n  incProgress(0.2, detail = \"Querying Database\")\n  res <- dbSendQuery(conn, sprintf(\"SELECT * FROM equipment_access WHERE \\\"X\\\" >= %.0f AND \\\"X\\\" <= %.0f AND \\\"Y\\\" >= %.0f AND \\\"Y\\\" <= %.0f LIMIT %.0f\", x_min, x_max, y_min, y_max, max_fetch))\n\n  incProgress(0.4, detail = \"Processing Data\")\n  f <- dbFetch(res)\n\n  if (nrow(f) == 0) {\n    print(\"No squared referenced in this area\")\n    return()\n  }\n\n  data_sf_4326 <- dbCoordsToLeaflet(f)\n\n\n  incProgress(0.3, detail = \"Rendering Map\")\n  for (elt2 in seq_len(nrow(data_sf_4326))) {\n    elt <- data_sf_4326[elt2, ]\n\n    # leafletProxy(\"map_background\") %>% addMarkers(\n    # lng = st_coordinates(elt)[,1],\n    # lat = st_coordinates(elt)[,2],\n    # label = elt$Label\n    # )\n    bottomRightPoint <- destPoint(st_coordinates(elt)[1, ], 135, sqrt(2) * 100)\n    topLeftPoint <- destPoint(st_coordinates(elt)[1, ], 315, sqrt(2) * 100)\n    leafletProxy(\"map_background\") %>% addRectangles(\n      lng1 = topLeftPoint[1],\n      lat1 = topLeftPoint[2],\n      lng2 = bottomRightPoint[1],\n      lat2 = bottomRightPoint[2],\n      color = \"green\",\n      label = elt$Label\n    )\n  }\n}\n\nselectSquare <- function(input, plot_data_rv, selected_point_rv, table_data_rv) {\n  click_pos <- input$map_background_click\n\n  df <- data.frame(click_pos$lng, click_pos$lat)\n  colnames(df) <- c(\"X\", \"Y\")\n\n  data_sf_orig <- st_as_sf(\n    df,\n    coords = c(\"X\", \"Y\"),\n    crs = 4326\n  )\n\n  data_sf_3035 <- st_transform(data_sf_orig, 3035)\n\n  coords_3035 <- st_coordinates(data_sf_3035)\n\n  x <- coords_3035[1, 1]\n  y <- coords_3035[1, 2]\n\n  x_range_min <- x - 100\n  x_range_max <- x + 100\n  y_range_min <- y - 100\n  y_range_max <- y + 100\n\n  query <- sprintf(\n    \"\n  SELECT *,\n         SQRT(POW(\\\"X\\\" - %.0f, 2) + POW(\\\"Y\\\" - %.0f, 2)) AS calculated_distance\n  FROM equipment_access\n  WHERE \\\"X\\\" BETWEEN %.0f AND %.0f AND \\\"Y\\\" BETWEEN %.0f AND %.0f\n  ORDER BY calculated_distance ASC\n  LIMIT 1\",\n    x, y, x_range_min, x_range_max, y_range_min, y_range_max\n  )\n\n\n  res <- dbSendQuery(conn, query)\n  nearest_point <- dbFetch(res)\n\n  if (nrow(nearest_point) == 0) {\n    print(\"No data for given area\")\n    leafletProxy(\"map_background\") %>% clearMarkers()\n    return()\n  }\n\n  selected_point_rv(nearest_point)\n\n  query <- sprintf(\"SELECT * FROM equipment_access WHERE \\\"X\\\" = %.0f AND \\\"Y\\\" = %.0f ORDER BY distance ASC\", nearest_point$X, nearest_point$Y)\n  res <- dbSendQuery(conn, query)\n  tableData <- dbFetch(res)\n  table_data_rv(tableData)\n\n  # TODO: after merge call find square to link plots to user selection\n  findSquare(data.frame(X = nearest_point$X, Y = nearest_point$Y), input, plot_data_rv)\n  data_sf_4326 <- dbCoordsToLeaflet(nearest_point)\n  leafletProxy(\"map_background\") %>%\n    clearMarkers() %>%\n    addMarkers(\n      lng = st_coordinates(data_sf_4326)[1, 1],\n      lat = st_coordinates(data_sf_4326)[1, 2],\n    )\n}\n\n\ndbCoordsToLeaflet <- function(df) {\n  data_df_orig <- data.frame(\n    X = df$X,\n    Y = df$Y,\n    Label = df$pop\n  ) %>% distinct()\n\n  data_sf_orig <- st_as_sf(\n    data_df_orig,\n    coords = c(\"X\", \"Y\"),\n    crs = 3035\n  )\n\n  data_sf_4326 <- st_transform(data_sf_orig, 4326)\n\n  return(data_sf_4326)\n}\n\nfindSquare <- function(point, input, plot_data_rv) {\n  eq <- input$selectEquimpent\n  if (eq == \".\") {\n    eq <- \"\"\n  }\n  equipment_type <- dbQuoteString(conn, paste0(eq, \"%\"))\n\n  if (is.null(point) || nrow(point) == 0) {\n    plot_data_rv(data.frame())\n    return()\n  }\n\n  res <- dbSendQuery(conn, sprintf(\n    \"SELECT * FROM equipment_access WHERE \\\"X\\\" = %.0f AND \\\"Y\\\" = %.0f AND \\\"typeeq_id\\\" LIKE %s\",\n    point$X, point$Y, equipment_type\n  ))\n  plot_data_rv(dbFetch(res))\n  dbClearResult(res)\n}\n\n# Creates a list containing the number of inhabitants and bugdet per inhabitant in all cities present in the culture dataset\ngetNbInhabitant <- function(input) {\n  query <- dbSendQuery(conn, sprintf(\"SELECT DISTINCT depcom FROM equipment_access\"))\n  cities <- dbFetch(query)\n  dbClearResult(query)\n  inhabitantsFrance <- data.frame(City = culture$Code_Insee, Inhabitants = culture$Population.2023, BudgetPerInhabitant = culture$Depenses_culturelles_totales.euros.par.habitant, GlobalBudget = culture$Depenses_culturelles_totales..K..)\n  inhabitantsDataset <- inhabitantsFrance[inhabitantsFrance$City %in% cities$depcom, ]\n  return(inhabitantsDataset)\n}\n\n# Create a dataset containing the mean distance and time to a cultural equimpment from each city present in getNbInhabitant\ncomputeDistTimeToCulture <- function(input) {\n  infoCity <- getNbInhabitant(input)\n  city_list <- paste0(\"'\", infoCity$City, \"'\", collapse = \", \")\n  city_list_sql <- sprintf(\"(%s)\", city_list)\n  query <- dbSendQuery(conn, sprintf(\"SELECT depcom, typeeq_id, distance, duree FROM equipment_access WHERE depcom IN %s AND typeeq_id LIKE 'F3%%'\", city_list_sql))\n  dataCitites <- dbFetch(query)\n  dbClearResult(query)\n\n  if (nrow(dataCitites) == 0) {\n    return(data.frame())\n  }\n\n  res_agg <- aggregate(list(mean_distance = dataCitites$distance, mean_time = dataCitites$duree),\n    by = list(City = dataCitites$depcom, eq_culture = dataCitites$typeeq_id),\n    FUN = mean\n  )\n\n  totalInfo <- merge(res_agg, infoCity, by = \"City\")\n  totalInfo$is_close <- as.integer(totalInfo$mean_time < 10)\n  colnames(totalInfo) <- c(\"City\", \"eq_culture\", \"mean_distance\", \"mean_time\", \"population\", \"budget_per_inhabitant\", \"global_budget\", \"is_close\")\n  return(totalInfo)\n}\n\n# Create a dataset containing the mean distance to an equipment depending on the size of the population of a city\ncomputeTimeToCultureForPopSize <- function(input) {\n  timeToCulture <- computeDistTimeToCulture(input)\n\n  if (nrow(timeToCulture) == 0) {\n    return(data.frame())\n  }\n\n  popSize_labels <- c(\"1-99\", \"100-999\", \"1000-9999\", \"10000-99999\", \"100000+\")\n\n  timeToCulture$pop_size_category <- cut(timeToCulture$population,\n    breaks = c(0, 99, 999, 9999, 99999, Inf),\n    labels = popSize_labels,\n    right = TRUE\n  )\n\n  # Aggregate mean time by both population size category and equipment type\n  result <- aggregate(list(mean_time = timeToCulture$mean_time),\n    by = list(\n      pop_size_category = timeToCulture$pop_size_category,\n      eq_culture = timeToCulture$eq_culture\n    ),\n    FUN = mean\n  )\n\n  return(result)\n}\n\n\nserver <- function(input, output) {\n  plot_data <- reactiveVal(data.frame())\n  table_data <- reactiveVal(data.frame())\n  selected_point <- reactiveVal(NULL)\n\n  observeEvent(input$map_background_click, {\n    selectSquare(input, plot_data, selected_point, table_data)\n  })\n\n\n  res <- dbSendQuery(conn, \"SELECT * FROM equipment_access LIMIT 10\")\n  f <- dbFetch(res)\n  print(f)\n\n  leaf <- leaflet() %>%\n    addTiles()\n\n  observeEvent(input$map_background_bounds, {\n    withProgress(message = \"Loading data...\", value = 0, {\n      fetchDB(input)\n    })\n  })\n\n  observeEvent(input$color_map_bounds, {\n    withProgress(message = \"Loading heatmap...\", value = 0, {\n      fetchDBColor(input)\n    })\n  })\n\n  data_sf_4326 <- dbCoordsToLeaflet(f)\n\n  color_map <- leaflet() %>%\n    addTiles()\n\n  for (elt2 in seq_len(nrow(data_sf_4326))) {\n    elt <- data_sf_4326[elt2, ]\n\n    leaf <- addMarkers(\n      map = leaf,\n      lng = st_coordinates(elt)[, 1],\n      lat = st_coordinates(elt)[, 2],\n      label = elt$Label\n    )\n    bottomRightPoint <- destPoint(st_coordinates(elt)[1, ], 135, sqrt(2) * 100)\n    topLeftPoint <- destPoint(st_coordinates(elt)[1, ], 315, sqrt(2) * 100)\n    leaf <- addRectangles(\n      map = leaf,\n      lng1 = topLeftPoint[1],\n      lat1 = topLeftPoint[2],\n      lng2 = bottomRightPoint[1],\n      lat2 = bottomRightPoint[2],\n      color = \"green\"\n    )\n\n    color_map <- addRectangles(\n      map = color_map,\n      lng1 = topLeftPoint[1],\n      lat1 = topLeftPoint[2],\n      lng2 = bottomRightPoint[1],\n      lat2 = bottomRightPoint[2],\n      color = \"blue\"\n    )\n  }\n  observeEvent(input$selectEquimpent, {\n    if (!is.null(selected_point())) {\n      findSquare(selected_point(), input, plot_data)\n    }\n  })\n\n  observeEvent(input$selectedEquipementColorMap, {})\n\n\n  output$table <- renderTable({\n    d <- plot_data()\n    req(nrow(d) > 0)\n    d_ordered <- d[order(d$duree), ]\n    code_signification <- setNames(legend$Libelle_TYPEQU, legend$TYPEQU)\n    d_ordered$signification <- sapply(d_ordered$typeeq_id, function(x) code_signification[match(x, names(code_signification))])\n    d_ordered[, c(15, 5, 7)]\n  })\n\n  output$distPlot <- renderPlot({\n    f <- plot_data()\n    req(nrow(f) > 0)\n\n    h <- hist(f$duree,\n      col = \"#007bc2\", border = \"white\",\n      xlab = \"Duration of travel from the square to an equipment (in minutes)\",\n      ylab = \"Number of equipments\",\n      main = \"Histogram of travel time to an equipment\",\n      xaxt = \"n\",\n      yaxt = \"n\"\n    )\n    axis(1, at = seq(0, max(f$duree, na.rm = TRUE) + 20, by = 20))\n    axis(2, at = seq(0, max(h$counts) + 5, by = 5))\n  })\n\n  # output$culturalBudgetPerInhabitantToCloseEqPlot <- renderPlot({\n  #  culturalData <- computeDistTimeToCulture(input)\n  #  req(nrow(culturalData) > 0)\n  #\n  #  city_data <- aggregate(list(is_close = culturalData$is_close),\n  #    by = list(City = culturalData$City),\n  #    FUN = sum\n  #  )\n  #\n  #  city_budget <- unique(culturalData[, c(\"City\", \"budget_per_inhabitant\")])\n  #\n  #  plot_culture <- merge(city_data, city_budget, by = \"City\")\n  #  plot(\n  #    x = plot_culture$budget_per_inhabitant, y = plot_culture$is_close,\n  #    xlab = \"Budget par Habitant\",\n  #    ylab = \"Nombre de type d'équipement à moins de 10 min\",\n  #    main = \"Budget Par Habitant Alloué à la Culture vs. Accès à un équipement culturel\",\n  #    pch = 19, col = \"#007bc2\"\n  #  )\n  # })\n\n  output$distToCulturalEQPerInhabitantPlot <- renderPlot({\n    data <- computeTimeToCultureForPopSize(input)\n    req(nrow(data) > 0)\n\n    # Get unique equipment types and assign colors\n    equipment_types <- unique(data$eq_culture)\n    colors <- rainbow(length(equipment_types))\n    equipment_colors <- setNames(colors, equipment_types)\n\n    # Get equipment labels from legend\n    code_signification <- setNames(legend$Libelle_TYPEQU, legend$TYPEQU)\n\n    # Convert data to wide format for grouped barplot\n    plot_data <- data\n    plot_data$eq_label <- sapply(\n      plot_data$eq_culture,\n      function(x) code_signification[match(x, names(code_signification))]\n    )\n\n    # Create matrix for barplot\n    pop_categories <- unique(plot_data$pop_size_category)\n    barplot_matrix <- matrix(NA, nrow = length(equipment_types), ncol = length(pop_categories))\n    rownames(barplot_matrix) <- sapply(equipment_types, function(x) code_signification[match(x, names(code_signification))])\n    colnames(barplot_matrix) <- pop_categories\n\n    for (i in seq_along(equipment_types)) {\n      for (j in seq_along(pop_categories)) {\n        subset_data <- plot_data[plot_data$eq_culture == equipment_types[i] &\n          plot_data$pop_size_category == pop_categories[j], ]\n        if (nrow(subset_data) > 0) {\n          barplot_matrix[i, j] <- subset_data$mean_time[1]\n        }\n      }\n    }\n\n    # Create grouped barplot\n    barplot(barplot_matrix,\n      beside = TRUE,\n      col = colors,\n      xlab = \"Population\",\n      ylab = \"Temps moyen de trajet (en minutes)\",\n      main = \"Temps de trajet moyen vers un équipement culturel en fonction de la taille de la population\",\n      legend.text = rownames(barplot_matrix),\n      args.legend = list(x = \"topright\")\n    )\n  })\n\n  print(\"Server update done!\")\n\n  output$map_background <- renderLeaflet({\n    leaf\n  })\n  output$color_map <- renderLeaflet({\n    color_map\n  })\n}\n\n\nfetchDBColor <- function(input) {\n  north_lat <- input$color_map$north\n  south_lat <- input$color_map$south\n  leafletProxy(\"color_map\") %>%\n    clearMarkers() %>%\n    clearShapes()\n\n  df <- data.frame(c(input$color_map_bounds$west, input$color_map_bounds$east), c(input$color_map_bounds$north, input$color_map_bounds$south))\n  colnames(df) <- c(\"X\", \"Y\")\n\n  data_sf_orig <- st_as_sf(\n    df,\n    coords = c(\"X\", \"Y\"),\n    crs = 4326\n  )\n\n  data_sf_3035 <- st_transform(data_sf_orig, 3035)\n\n  coords_3035 <- st_coordinates(data_sf_3035)\n  x_min <- min(coords_3035[, 1])\n  x_max <- max(coords_3035[, 1])\n  y_min <- min(coords_3035[, 2])\n  y_max <- max(coords_3035[, 2])\n\n  max_fetch <- input$slider\n\n  eq <- input$selectedEquipementColorMap\n  print(eq)\n  if (is.null(eq)) {\n    eq <- \"\"\n  }\n  equipment_type <- dbQuoteString(conn, paste0(eq, \"%\"))\n\n  incProgress(0.2, detail = \"Querying Database\")\n  res <- dbSendQuery(conn, sprintf(\"SELECT * FROM equipment_access WHERE \\\"X\\\" >= %.0f AND \\\"X\\\" <= %.0f AND \\\"Y\\\" >= %.0f AND \\\"Y\\\" <= %.0f AND \\\"typeeq_id\\\" LIKE %s LIMIT %.0f\", x_min, x_max, y_min, y_max, equipment_type, max_fetch))\n\n  incProgress(0.4, detail = \"Processing Data\")\n  f <- dbFetch(res)\n\n  if (nrow(f) == 0) {\n    print(\"No squared referenced in this area\")\n    return()\n  }\n\n  f$pop <- f$dist\n\n  data_sf_4326 <- dbCoordsToLeaflet(f)\n\n\n  incProgress(0.3, detail = \"Rendering Map\")\n  for (elt2 in seq_len(nrow(data_sf_4326))) {\n    elt <- data_sf_4326[elt2, ]\n\n    # leafletProxy(\"color_map\") %>% addMarkers(\n    # lng = st_coordinates(elt)[,1],\n    # lat = st_coordinates(elt)[,2],\n    # label = elt$Label\n    # )\n    color <- \"black\"\n    if (!is.null(elt$Label)) {\n      scale <- input$colorMapScale\n      if (elt$Label < scale[5]) {\n        color <- \"purple\"\n      }\n      if (elt$Label < scale[4]) {\n        color <- \"red\"\n      }\n      if (elt$Label < scale[3]) {\n        color <- \"orange\"\n      }\n      if (elt$Label < scale[2]) {\n        color <- \"yellow\"\n      }\n      if (elt$Label < scale[1]) {\n        color <- \"green\"\n      }\n    }\n\n    bottomRightPoint <- destPoint(st_coordinates(elt)[1, ], 135, sqrt(2) * 100)\n    topLeftPoint <- destPoint(st_coordinates(elt)[1, ], 315, sqrt(2) * 100)\n    leafletProxy(\"color_map\") %>% addRectangles(\n      lng1 = topLeftPoint[1],\n      lat1 = topLeftPoint[2],\n      lng2 = bottomRightPoint[1],\n      lat2 = bottomRightPoint[2],\n      color = color,\n      label = elt$Label\n    )\n  }\n}\n","type":"text"},{"name":"src/ui.R","content":"library(shiny)\nlibrary(shinyWidgets)\n\nui <- page_sidebar(\n  tags$head(\n    tags$style(HTML(\"\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(1) { background: green; }\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(2) { background: yellow; }\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(3) { background: orange; }\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(4) { background: red; }\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(5) { background: purple; }\n      #colorMapScale .noUi-connects .noUi-connect:nth-child(6) { background: black; }\n    \"))\n  ),\n  title = \"Visualisation 2025\",\n  sidebar = sidebar(\n    position = \"left\",\n    sliderInput(\"slider\", label = \"Max number of areas to show\", min = 1000, max = 500000, value = 10000),\n  ),\n  navset_card_underline(\n    nav_panel(\n      title = \"General view\",\n      layout_columns(\n        card(\n          card_header(\"Map of Equipment Access\"),\n          leafletOutput(\"map_background\"),\n        ),\n        card(\n          card_header(\"Travel Time Distribution\"),\n          selectInput(\"selectEquimpent\",\n            label = \"Select Equipment category\",\n            choices = list(\n              \"GLOBAL\" = \".\",\n              \"SERVICES POUR LES PARTICULIERS \" = \"A\",\n              \"COMMERCES\" = \"B\",\n              \"ENSEIGNEMENT\" = \"C\",\n              \"SANTÉ ET ACTION SOCIALE\" = \"D\",\n              \"TRANSPORTS ET DÉPLACEMENTS \" = \"E\",\n              \"SPORTS, LOISIRS ET CULTURE \" = \"F\",\n              \"TOURISME\" = \"G\"\n            ),\n            selected = \".\"\n          ),\n          plotOutput(outputId = \"distPlot\"),\n          div(style = \"overflow-y: auto; height: 300px;\", tableOutput(outputId = \"table\"))\n        )\n      )\n    ),\n    nav_panel(\n      title = \"Heatmap\",\n      layout_columns(\n        leafletOutput(\"color_map\"),\n        card(\n          selectizeInput(\n            inputId = \"selectedEquipementColorMap\",\n            label = \"Select an equipement\",\n            choices = setNames(legend$TYPEQU, legend$Libelle_TYPEQU),\n            selected = NULL,\n            multiple = FALSE,\n            options = NULL\n          ),\n          noUiSliderInput(\n            inputId = \"colorMapScale\",\n            label = \"Select:\",\n            min = 0,\n            max = 150,\n            value = c(10, 20, 50, 100, 125),\n            tooltips = TRUE,\n            step = 1,\n            width = \"100%\",\n            color = \"#007bc2\",\n            update_on = \"end\",\n            connect = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE),\n            format = wNumbFormat(decimals = 0)\n          ),\n          layout_columns(\n            col_widths = c(1, 1),\n            actionButton(\n              inputId = \"cancel\",\n              label = \"reset\",\n              width = \"30%\"\n            ),\n            actionButton(\n              inputId = \"test\",\n              label = \"Update Color Pallet\",\n              width = \"75%\"\n            )\n          )\n        ),\n      )\n    ),\n    nav_panel(\n      title = \"Accès à la culture\",\n      # we don't see a correlation, not shown in the app but in the presentation\n      # card(\n      #  plotOutput(outputId= \"culturalBudgetToCloseEqPlot\")\n      # ),\n      # card(\n      #  plotOutput(outputId= \"culturalBudgetPerInhabitantToCloseEqPlot\")\n      # ),\n      card(\n        # select box to choose an equipment to display\n        plotOutput(outputId = \"distToCulturalEQPerInhabitantPlot\")\n      )\n    ),\n    nav_panel(\n      title = \"About\",\n      card(\n        card_header(\"Information\"),\n        p(\"This General view tab displays equipment access and travel time distributions across various regions.\"),\n        p(\"Other tabs containing different visualisations will be added later\"),\n        p(\"On the sidebar, you can choose to display more squares\")\n      )\n    )\n  )\n)\n","type":"text"}]
